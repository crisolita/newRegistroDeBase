// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;
pragma abicoder v2;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "hardhat/console.sol";

/**
 * @title BlockToWin Platform
 * @author Crisol Cova
 * @notice BlockToWin allows you to submit documents that can be verified
 * in IPFS
 */
contract BlockToWin is
  Initializable,
  ContextUpgradeable,
  AccessControlUpgradeable,
  ERC20Upgradeable,
  ReentrancyGuardUpgradeable
{
  ///@notice the current id to reference the lottery
  uint256 public currentDataLotteryId;
  /**
   * @notice Retrieves the amount of documents submitted.
   * @return The counter of the documents.
   */
  uint256 public documentsCount;
  ///@notice a struct to storage every lottery
  struct DataLottery {
    uint256 dataLotteryId;
    uint256[] winners;
    uint256[] alternates;
    string ipfsDataBack;
    uint256 idDocument;
  }

  ///@notice document
  struct Document {
    address owner;
    string name;
    string promo;
    uint256 validityStart;
    uint256 validityEnd;
    string hash;
    uint256 uploadedAt;
    string explorerLink;
    string ipfsLink;
    bool isVisible;
  }

  mapping(uint256 => Document) public documents;
  mapping(uint256 => Document) public canceledDocuments;
  ///@notice mapping ids of lottery to struct to storage all the lotteries
  mapping(uint256 => DataLottery) public dataLotteryRecord;
  DataLottery[] public allData;

  /**
   *  @notice This is the enum for the types of owner that it can be own a document.
   */
  enum TypeOfOwner {
    COMPANY,
    USER
  }

  event NewSort(
    uint256 _players,
    uint256[] _winners,
    uint256[] _alternates,
    string _ipfsHash,
    uint256
  );
  /**
   * @dev Emitted when `approval' submits a document.
   */
  event DocumentSubmitted(
    address indexed approval,
    string name,
    string promo,
    string hash,
    uint256 uploadedAt,
    string ext
  );
  event CanceledDocument(uint256 index);

  modifier onlyOwner() {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Not owner");
    _;
  }

  function initialize(address[] memory admins) external initializer {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    for (uint256 i; i < admins.length; i++) {
      _setupRole(DEFAULT_ADMIN_ROLE, admins[i]);
    }
    __Context_init();
  }

  /// PUBLIC FUNCTIONS
  /**
   * @notice Allows to an approval submits a document.
   * @param name Name of the company/user.
   * @param promo Description of the promo.
   * @param validityStart Timestamp for the validity start, in unix
   * @param validityEnd Timestampt for the validity end, in unix
   * @param hash Hash generated by the IPFS
   * @param uploadedAt Timestamp for the generated document
   * @param explorerLink Link of the document hash in the explorer
   * @param ipfsLink Link of the document hash in the IPFS
   * @param ext Extension of the document (ex: .pdf .doc .txt)
   *
   * Emits a {DocumentSubmitted} event.
   */
  function submitDocument(
    string memory name,
    string memory promo,
    uint256 validityStart,
    uint256 validityEnd,
    string memory hash,
    uint256 uploadedAt,
    string memory explorerLink,
    string memory ipfsLink,
    string memory ext,
    bool isVisible
  ) public {
    require(!verifyDocument(hash), "BlockToWin: HASH_EXISTS");
    require(
      ERC20Upgradeable(this).balanceOf(msg.sender) > 0,
      "You cannot submit documents"
    );
    documents[documentsCount] = Document({
      owner: _msgSender(),
      name: name,
      promo: promo,
      validityStart: validityStart,
      validityEnd: validityEnd,
      hash: hash,
      uploadedAt: uploadedAt,
      explorerLink: explorerLink,
      ipfsLink: ipfsLink,
      isVisible: isVisible
    });
    documentsCount += 1;
    ERC20Upgradeable(this)._burn(msg.sender, 10**18);
    emit DocumentSubmitted(_msgSender(), name, promo, hash, uploadedAt, ext);
  }

  function chooseTheWinners(
    uint256 _totalPlayers,
    uint256 _numberOfWinners,
    string memory _ipfsDataBack
  ) private {
    uint256 j = 0;
    uint256 k = _totalPlayers;
    while (j < _numberOfWinners) {
      uint256 randomNumber = (uint256(
        keccak256(
          abi.encodePacked(block.timestamp, msg.sender, _ipfsDataBack, j, k)
        )
      ) % _totalPlayers) + 1;
      if (
        !isRepeated(
          randomNumber,
          dataLotteryRecord[currentDataLotteryId].winners
        )
      ) {
        dataLotteryRecord[currentDataLotteryId].winners.push(randomNumber);
        j++;
      } else {
        k++;
      }
    }
  }

  function isRepeated(uint256 _number, uint256[] memory _array)
    public
    pure
    returns (bool)
  {
    for (uint256 i = 0; i < _array.length; i++) {
      if (_number == _array[i]) {
        return true;
      }
    }
    return false;
  }

  function chooseTheAlternates(
    uint256 _totalPlayers,
    uint256 _numberOfAlternates,
    string memory _ipfsDataBack
  ) private {
    uint256 j = 0;
    uint256 k = _totalPlayers;
    while (j < _numberOfAlternates) {
      uint256 randomNumber = (uint256(
        keccak256(
          abi.encodePacked(block.timestamp, msg.sender, j, k, _ipfsDataBack)
        )
      ) % _totalPlayers) + 1;
      if (
        !isRepeated(
          randomNumber,
          dataLotteryRecord[currentDataLotteryId].winners
        ) &&
        !isRepeated(
          randomNumber,
          dataLotteryRecord[currentDataLotteryId].alternates
        )
      ) {
        dataLotteryRecord[currentDataLotteryId].alternates.push(randomNumber);
        j++;
      } else {
        k++;
      }
    }
  }

  ///@notice turn on the lottery and storage the results
  ///@notice returns the winners, alternate and hashExcel provide
  function shakeTheNumbers(
    string memory _ipfsDataBack,
    uint256 _totalPlayers,
    uint256 _numberOfWinners,
    uint256 _numberOfAlternates,
    uint256 _idDocument
  ) public returns (DataLottery memory) {
    require(
      _totalPlayers > _numberOfWinners,
      "Total players should be greater tha winners"
    );
    require(
      _totalPlayers - _numberOfWinners >= _numberOfAlternates,
      "Total players should be greater tha winners+alternates"
    );
    currentDataLotteryId++;
    dataLotteryRecord[currentDataLotteryId]
    .dataLotteryId = currentDataLotteryId;
    chooseTheWinners(_totalPlayers, _numberOfWinners, _ipfsDataBack);
    chooseTheAlternates(_totalPlayers, _numberOfAlternates, _ipfsDataBack);
    dataLotteryRecord[currentDataLotteryId].ipfsDataBack = _ipfsDataBack;
    dataLotteryRecord[currentDataLotteryId].idDocument = _idDocument;
    allData.push(dataLotteryRecord[currentDataLotteryId]);
    emit NewSort(
      _totalPlayers,
      dataLotteryRecord[currentDataLotteryId].winners,
      dataLotteryRecord[currentDataLotteryId].alternates,
      _ipfsDataBack,
      _idDocument
    );
    return dataLotteryRecord[currentDataLotteryId];
  }

  /**
   * @notice Change the visibility of a document if you are the owner of that document,
   * if you aren't the owner, it's just returning false.
   */
  function changeDocumentVisibility(uint256 documentIndex)
    external
    returns (bool)
  {
    require(
      documents[documentIndex].owner == _msgSender(),
      "BlockToWin: NOT_OWNER_DOCUMENT"
    );
    documents[documentIndex].isVisible = !documents[documentIndex].isVisible;
    return true;
  }

  /**
   *  @notice Removes a document at `index` in the mapping of documents
   */
  function removeDocument(uint256 index) external onlyOwner returns (bool) {
    if (documents[index].owner != address(0)) {
      delete documents[index];
      return true;
    }
    return false;
  }

  ///@notice this function register an user to allow them submit documents
  function registerAnUser(uint256 _amountOfDocuments, address _userAddress)
    public
    payable
    onlyOwner
    nonReentrant
  {
    require(msg.value > 0, "This function is payable");
    ERC20Upgradeable(this)._mint(_userAddress, _amountOfDocuments);
    payable(_userAddress).transfer(msg.value);
  }

  ///@notice cancel a document only the approval
  function cancelDocument(uint256 index) external returns (bool) {
    require(msg.sender == documents[index].owner, "You are not the owner");
    if (documents[index].owner != address(0)) {
      if (!documents[index].isVisible) {
        documents[index].isVisible = true;
      }
      canceledDocuments[index] = documents[index];
      delete documents[index];
      emit CanceledDocument(index);
      return true;
    }
    return false;
  }

  /**
   * @notice Returns true if `hash` already exist in a document
   */
  function verifyDocument(string memory hash) public view returns (bool) {
    for (uint256 i; i < documentsCount; i++) {
      if (keccak256(bytes(documents[i].hash)) == keccak256(bytes(hash))) {
        return true;
      }
    }
    return false;
  }

  ////VIEW DOCUMENTS
  function seeCurrentData() public view returns (DataLottery memory) {
    return dataLotteryRecord[currentDataLotteryId];
  }

  function seeDataUnique(uint256 _id) public view returns (DataLottery memory) {
    return dataLotteryRecord[_id];
  }
}
